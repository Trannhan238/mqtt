import asyncio
import os
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from contextlib import asynccontextmanager

from app.api import auth, schools, devices, schedules, patterns
from app.core.config import settings
from app.database.session import engine, SessionLocal
from app.models import domain
from app.core.mqtt_client import MQTTHandler
from app.services.schedule_service import ScheduleService
from fastapi_utils.tasks import repeat_every 

# --- 1. KH·ªûI T·∫†O H·ªÜ TH·ªêNG (Folder & Database) ---
if not os.path.exists("data"):
    os.makedirs("data")
    print("[System] ƒê√£ t·∫°o th∆∞ m·ª•c data cho s·∫øp!")

# T·∫°o b·∫£ng trong SQLite n·∫øu ch∆∞a c√≥
domain.Base.metadata.create_all(bind=engine)

# --- 2. HELPERS ---
@asynccontextmanager
async def get_schedule_service():
    """H√†m h·ªó tr·ª£ MQTT Handler l·∫•y d·ªØ li·ªáu t·ª´ DB"""
    db = SessionLocal()
    try:
        yield ScheduleService(db)
    finally:
        db.close()

# --- 3. QU·∫¢N L√ù V√íNG ƒê·ªúI ·ª®NG D·ª§NG (Lifespan) ---
@asynccontextmanager
async def lifespan(app: FastAPI):
    # L·∫•y mqtt_handler t·ª´ state ƒë√£ g·∫Øn ·ªü b∆∞·ªõc 5
    handler = app.state.mqtt_handler
    
    # Kh·ªüi ƒë·ªông Task MQTT ch·∫°y ng·∫ßm
    mqtt_task = asyncio.create_task(handler.connect())
    print(f"[System] MQTT Worker ƒëang k·∫øt n·ªëi t·ªõi {settings.MQTT_BROKER}...")
    
    yield
    
    # D·ªçn d·∫πp khi t·∫Øt Server
    if handler.client.is_connected:
        await handler.client.disconnect()
    mqtt_task.cancel()
    print("[System] MQTT Worker ƒë√£ ƒëi ng·ªß.")

# --- 4. KH·ªûI T·∫†O FASTAPI ---
# (Ph·∫£i t·∫°o app tr∆∞·ªõc khi g√°n app.state)
app = FastAPI(
    title=settings.PROJECT_NAME,
    lifespan=lifespan
)

# --- 5. KH·ªûI T·∫†O MQTT V√Ä G·∫ÆN V√ÄO STATE ---
# (ƒê√¢y l√† 'ch√¨a kh√≥a' ƒë·ªÉ c√°c file API kh√°c g·ªçi ƒë∆∞·ª£c MQTT)
mqtt_handler = MQTTHandler(get_schedule_service)
app.state.mqtt_handler = mqtt_handler 

# --- 6. C·∫§U H√åNH MIDDLEWARE (CORS) ---
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# --- 7. ƒêƒÇNG K√ù C√ÅC ROUTERS ---
app.include_router(auth.router)
app.include_router(schools.router)
app.include_router(devices.router)
app.include_router(schedules.router)
app.include_router(patterns.router)

# --- 8. HEALTH CHECK ---
@app.get("/", tags=["Health"])
async def health_check():
    return {
        "status": "online",
        "project": settings.PROJECT_NAME,
        "mqtt_broker": settings.MQTT_BROKER,
        "message": "Backend IOT School Bell ƒë√£ l√™n s√†n!"
    }


@app.on_event("startup")
@repeat_every(seconds=60) # C·ª© 60 gi√¢y ch·∫°y m·ªôt l·∫ßn
async def check_device_status():
    async with SessionLocal() as db:
        # T√¨m c√°c thi·∫øt b·ªã ƒë√£ qu√° 2 ph√∫t kh√¥ng th·∫•y t√≠n hi·ªáu
        timeout = datetime.now() - timedelta(minutes=2)
        offline_devices = db.query(Device).filter(
            Device.last_seen < timeout, 
            Device.status == "online"
        ).all()
        
        for dev in offline_devices:
            dev.status = "offline"
            print(f"üíÄ [Alert] Thi·∫øt b·ªã {dev.mac_address} ƒë√£ m·∫•t k·∫øt n·ªëi!")
            # ·ªû ƒë√¢y s·∫øp c√≥ th·ªÉ g·ªçi h√†m g·ª≠i Telegram t·∫°i ƒë√¢y
        
        db.commit()
# --- 9. CH·∫†Y SERVER ---
if __name__ == "__main__":
    import uvicorn
    # L∆∞u √Ω: file n√†y t√™n l√† main.py n√™n ƒë·ªÉ "main:app"
    uvicorn.run("main:app", host="0.0.0.0", port=8000, reload=True)