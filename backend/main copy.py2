import asyncio
import os
from datetime import datetime, timedelta
from contextlib import asynccontextmanager

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware

from app.api import auth, schools, devices, schedules, patterns
from app.core.config import settings
from app.database.session import engine, SessionLocal
from app.models.domain import Base, Device # Import tr·ª±c ti·∫øp model Device ƒë·ªÉ check health
from app.core.mqtt_client import MQTTHandler
from app.services.schedule_service import ScheduleService

# --- 1. KH·ªûI T·∫†O H·ªÜ TH·ªêNG ---
if not os.path.exists("data"):
    os.makedirs("data")
    print("[System] ƒê√£ t·∫°o th∆∞ m·ª•c data!")

# T·∫°o b·∫£ng database
Base.metadata.create_all(bind=engine)

# --- 2. WORKER KI·ªÇM TRA S·ª®C KH·ªéE (HEALTH CHECK) ---
async def device_health_monitor():
    """
    Worker ch·∫°y ng·∫ßm: C·ª© 60 gi√¢y qu√©t DB m·ªôt l·∫ßn.
    N·∫øu con chu√¥ng n√†o 'last_seen' qu√° 2 ph√∫t th√¨ cho n√≥ Offline.
    """
    while True:
        await asyncio.sleep(60) # Ngh·ªâ 1 ph√∫t
        db = SessionLocal()
        try:
            # T√≠nh m·ªëc th·ªùi gian b·ªã coi l√† "m·∫•t t√≠ch" (2 ph√∫t tr∆∞·ªõc)
            timeout_limit = datetime.now() - timedelta(minutes=2)
            
            # T√¨m c√°c √¥ng ƒëang 'online' nh∆∞ng th·ª±c t·∫ø ƒë√£ m·∫•t h√∫t
            zombie_devices = db.query(Device).filter(
                Device.status == "online",
                Device.last_seen < timeout_limit
            ).all()

            for dev in zombie_devices:
                dev.status = "offline"
                print(f"üíÄ [Alert] {dev.mac_address} ({dev.name}) ƒë√£ m·∫•t k·∫øt n·ªëi!")
                # S·∫øp c√≥ th·ªÉ th√™m h√†m g·ª≠i tin nh·∫Øn Telegram v√†o ƒë√¢y sau n√†y
            
            db.commit()
        except Exception as e:
            print(f"‚ùå [Health Monitor Error] {e}")
        finally:
            db.close()

# --- 3. QU·∫¢N L√ù V√íNG ƒê·ªúI (LIFESPAN) ---
@asynccontextmanager
async def lifespan(app: FastAPI):
    # 3.1. Kh·ªüi ƒë·ªông MQTT Worker
    handler = app.state.mqtt_handler
    mqtt_task = asyncio.create_task(handler.connect())
    print(f"üì° [System] MQTT k·∫øt n·ªëi t·ªõi {settings.MQTT_BROKER}...")
    
    # 3.2. Kh·ªüi ƒë·ªông Health Check Worker (Ch·∫°y song song)
    health_task = asyncio.create_task(device_health_monitor())
    print("üõ°Ô∏è [System] Qu·∫£n gia theo d√µi thi·∫øt b·ªã ƒë√£ b·∫Øt ƒë·∫ßu l√†m vi·ªác...")
    
    yield
    
    # 3.3. D·ªçn d·∫πp khi t·∫Øt Server
    health_task.cancel()
    if handler.client.is_connected:
        await handler.client.disconnect()
    mqtt_task.cancel()
    print("[System] ƒê√£ t·∫Øt to√†n b·ªô t√°c v·ª• ch·∫°y ng·∫ßm. Ngh·ªâ ng∆°i th√¥i s·∫øp!")

# --- 4. KH·ªûI T·∫†O FASTAPI ---
app = FastAPI(
    title=settings.PROJECT_NAME,
    lifespan=lifespan
)

# --- 5. SETUP MQTT STATE ---
@asynccontextmanager
async def get_schedule_service():
    db = SessionLocal()
    try:
        yield ScheduleService(db)
    finally:
        db.close()

app.state.mqtt_handler = MQTTHandler(get_schedule_service)

# --- 6. MIDDLEWARE & ROUTERS ---
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

app.include_router(auth.router)
app.include_router(schools.router)
app.include_router(devices.router)
app.include_router(schedules.router)
app.include_router(patterns.router)

# --- 7. HOME ---
@app.get("/", tags=["Health"])
async def health_check():
    return {
        "status": "online",
        "project": settings.PROJECT_NAME,
        "message": "H·ªá th·ªëng Chu√¥ng th√¥ng minh ƒëang ch·∫°y c·ª±c m∆∞·ª£t!"
    }

if __name__ == "__main__":
    import uvicorn
    uvicorn.run("main:app", host="0.0.0.0", port=8000, reload=True)